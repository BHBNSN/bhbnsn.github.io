<!DOCTYPE html>
<html>
<head>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // 调整字体大小和下落速度
        const FONT_PX = 15;
        const FALL_SPEED = 0.4;

        // 初始化画布尺寸
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // 根据画布宽度和字体大小计算最大列数（每列宽度为FONT_PX）
        const columns = Math.floor(canvas.width / FONT_PX);

        // 创建与列数相同的数组，记录每列字符的当前下落位置（初始都在顶部0位置）
        const drops = Array(columns).fill(0);

        // 定义要循环显示的字符数组（LOVE四个字母）
        const texts = ['L', 'O', 'V', 'E'];

        // 创建与列数相同的数组，记录每列当前使用的字符索引（初始都从第0个字符开始）
        const charIndexes = Array(columns).fill(0);

        // 动画循环函数
        function animate() {

            // 用半透明黑色覆盖画布，实现渐隐拖尾效果（值越小拖尾越长）
             ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
             ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 仅循环处理前2列（示例代码简化版，实际应该循环所有列）
            for (let i = 0; i < 2000; i++) {
                // 设置字符颜色为亮粉色
                ctx.fillStyle = '#FF69B4';
                // 设置等宽字体样式（字体大小由FONT_PX常量定义）
                ctx.font = `${FONT_PX}px monospace`;

                // 绘制当前字符：列位置i*FONT_PX，纵坐标drops[i]*FONT_PX
                ctx.fillText(texts[3], i * FONT_PX, drops[i] * FONT_PX);

                // 控制下落速度：每次循环下落1个字符高度（值越大下落越快）
                drops[i] += 1;
                // 再次绘制字符（可能试图制造重叠效果，但逻辑存在问题）
                ctx.fillText(texts[2], i * FONT_PX, drops[i] * FONT_PX);

                drops[i] += 1;
                // 再次绘制字符（可能试图制造重叠效果，但逻辑存在问题）
                ctx.fillText(texts[1], i * FONT_PX, drops[i] * FONT_PX);

                drops[i] += 1;
                // 再次绘制字符（可能试图制造重叠效果，但逻辑存在问题）
                ctx.fillText(texts[0], i * FONT_PX, drops[i] * FONT_PX);

                // 重置条件：当字符超出画布底部，或随机数>0.97时（3%概率）
                if (drops[i] * FONT_PX > canvas.height + FONT_PX || Math.random() > 0.97) {
                    drops[i] = 0; // 重置下落位置到顶部
                    charIndexes[i] = (charIndexes[i] + 1) % texts.length; // 切换到下一个字符
                }
            }

            // 继续请求下一帧动画

            requestAnimationFrame(animate);

        }

        // 启动动画
        animate();
    </script>
</body>
</html>