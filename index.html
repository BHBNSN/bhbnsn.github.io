<!DOCTYPE html>
<html>
<head>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // 调整字体大小和下落速度
        const FONT_PX = 15;
        const FALL_SPEED = 0.4;

        // 初始化画布尺寸
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // 根据画布宽度和字体大小计算最大列数（每列宽度为FONT_PX）
        const columns = Math.floor(canvas.width / FONT_PX);

        // 创建与列数相同的数组，记录每列字符的当前下落位置（初始都在顶部0位置）
        const drops = Array(columns).fill(0);

        // 定义要循环显示的字符数组（LOVE四个字母）
        const texts = ['L', 'O', 'V', 'E'];

        // 创建与列数相同的数组，记录每列当前使用的字符索引（初始都从第0个字符开始）
        const charIndexes = Array(columns).fill(0);

        // 动画循环函数
        function animate() {

            // 用半透明黑色覆盖画布，实现渐隐拖尾效果（值越小拖尾越长）
             ctx.fillStyle = 'rgba(0, 0, 0, 1)';
             ctx.fillRect(0, 0, canvas.width, canvas.height);

             for(let j = 26; j > 0; j--) {


                 // 仅循环处理前2列（示例代码简化版，实际应该循环所有列）
                 for (let i = 0; i < columns; i++) {
                     // 设置字符颜色为亮粉色
                     ctx.fillStyle = '#FF69B4';
                     // 设置等宽字体样式（字体大小由FONT_PX常量定义）
                     ctx.font = `${FONT_PX}px monospace`;

                     ctx.fillText(texts[(j-1)%4], i * FONT_PX, (drops[i]-j) * FONT_PX);

                     if(j === 1){
                         drops[i] += 0.5;
                     }

                     // 重置条件：当字符超出画布底部，或随机数>0.97时（3%概率）
                     if ((drops[i] - 26) * FONT_PX > canvas.height + FONT_PX || Math.random() > 0.9997) {
                         drops[i] = 0; // 重置下落位置到顶部
                         charIndexes[i] = (charIndexes[i] + 1) % texts.length; // 切换到下一个字符
                     }
                 }

                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

             }


            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            //ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 继续请求下一帧动画

            requestAnimationFrame(animate);

        }

        // 启动动画
        animate();
    </script>
</body>
</html>